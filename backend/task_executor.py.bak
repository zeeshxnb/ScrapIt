"""
Gmail Task Execution System
Handles complex multi-step email management tasks via Gmail API
"""
import os
import time
import uuid
from enum import Enum
from typing import List, Dict, Any, Optional, Union
from datetime import datetime
from pydantic import BaseModel
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session

from database import get_db
from models import User, Email, Task
from auth import get_current_user
from gmail import GmailService

router = APIRouter()

class TaskStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class TaskType(str, Enum):
    EMAIL_CLEANUP = "email_cleanup"
    EMAIL_ORGANIZATION = "email_organization"
    EMAIL_SEARCH = "email_search"
    EMAIL_COMPOSE = "email_compose"
    EMAIL_SEND = "email_send"
    CUSTOM = "custom"

class TaskAction(str, Enum):
    DELETE = "DELETE"
    ARCHIVE = "ARCHIVE"
    LABEL = "LABEL"
    MOVE = "MOVE"
    SEARCH = "SEARCH"
    COMPOSE = "COMPOSE"
    SEND = "SEND"
    MARK_READ = "MARK_READ"
    MARK_UNREAD = "MARK_UNREAD"
    STAR = "STAR"
    UNSTAR = "UNSTAR"

class TaskStep(BaseModel):
    action: TaskAction
    params: Dict[str, Any]
    completed: bool = False
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class TaskRequest(BaseModel):
    task_type: TaskType
    description: str
    steps: List[TaskStep]
    priority: int = 1  # 1 (highest) to 5 (lowest)

class TaskResponse(BaseModel):
    task_id: str
    status: TaskStatus
    description: str
    created_at: datetime
    updated_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    progress: int = 0
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

def create_task(db: Session, user_id: str, task_request: TaskRequest) -> Task:
    """Create a new task in the database"""
    task_id = str(uuid.uuid4())
    now = datetime.utcnow()
    
    task = Task(
        id=task_id,
        user_id=user_id,
        type=task_request.task_type,
        description=task_request.description,
        status=TaskStatus.PENDING,
        steps=task_request.dict().get("steps"),
        priority=task_request.priority,
        created_at=now,
        updated_at=now
    )
    
    db.add(task)
    db.commit()
    db.refresh(task)
    
    return task

async def execute_task(db: Session, task: Task, user: User) -> Dict[str, Any]:
    """Execute a task with multiple steps with comprehensive error handling and logging"""
    import logging
    
    # Configure logger
    logger = logging.getLogger("task_executor")
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
    
    task_id = task.id
    logger.info(f"[Task {task_id}] Starting execution of task: {task.description}")
    
    if task.status == TaskStatus.COMPLETED:
        logger.info(f"[Task {task_id}] Task already completed")
        return {"message": "Task already completed", "task_id": task.id}
    
    if task.status == TaskStatus.FAILED:
        logger.info(f"[Task {task_id}] Task previously failed: {task.error}")
        return {"message": "Task previously failed", "task_id": task.id, "error": task.error}
    
    # Mark task as in progress
    try:
        task.status = TaskStatus.IN_PROGRESS
    task.updated_at = datetime.utcnow()
    db.commit()
        logger.info(f"[Task {task_id}] Task marked as in progress")
    except Exception as e:
        logger.error(f"[Task {task_id}] Failed to update task status: {str(e)}")
        return {"message": "Failed to update task status", "task_id": task.id, "error": str(e)}
    
    # Send initial notification
    try:
        from notification import notify_task_update
        await notify_task_update(task)
        logger.info(f"[Task {task_id}] Sent initial notification")
    except Exception as e:
        logger.warning(f"[Task {task_id}] Failed to send initial notification: {str(e)}")
    
    # Initialize Gmail service
    try:
        gmail_service = GmailService(user)
        authenticated = gmail_service.authenticate()
        if not authenticated:
            error_msg = "Failed to authenticate with Gmail API"
            logger.error(f"[Task {task_id}] {error_msg}")
            task.status = TaskStatus.FAILED
            task.error = error_msg
            task.updated_at = datetime.utcnow()
            db.commit()
            return {"message": "Task failed", "task_id": task.id, "error": error_msg}
        logger.info(f"[Task {task_id}] Gmail service initialized and authenticated")
    except Exception as e:
        error_msg = f"Failed to initialize Gmail service: {str(e)}"
        logger.error(f"[Task {task_id}] {error_msg}")
        task.status = TaskStatus.FAILED
        task.error = error_msg
        task.updated_at = datetime.utcnow()
        db.commit()
        return {"message": "Task failed", "task_id": task.id, "error": error_msg}
    
    total_steps = len(task.steps)
    completed_steps = 0
    results = {}
    
    logger.info(f"[Task {task_id}] Starting execution of {total_steps} steps")
    
    try:
        for i, step in enumerate(task.steps):
            step_number = i + 1
            action = step.get("action")
            params = step.get("params", {})
            
            if step.get("completed"):
                logger.info(f"[Task {task_id}] Step {step_number}/{total_steps} ({action}) already completed, skipping")
                completed_steps += 1
                continue
                
            logger.info(f"[Task {task_id}] Executing step {step_number}/{total_steps}: {action} with params: {params}")
            
            # Validate step before execution
            if not validate_step(step, logger, task_id, step_number):
                error_msg = f"Invalid step configuration: {step}"
                logger.error(f"[Task {task_id}] {error_msg}")
                task.status = TaskStatus.FAILED
                task.error = error_msg
                task.updated_at = datetime.utcnow()
                db.commit()
                return {"message": "Task failed", "task_id": task.id, "error": error_msg}
                
            # Execute the step with more detailed error handling
            try:
        step_result = execute_step(step, gmail_service, db, user)
                logger.info(f"[Task {task_id}] Step {step_number}/{total_steps} completed successfully: {step_result}")
            except Exception as step_error:
                error_msg = f"Step {step_number} ({action}) failed: {str(step_error)}"
                logger.error(f"[Task {task_id}] {error_msg}")
                task.status = TaskStatus.FAILED
                task.error = error_msg
                task.updated_at = datetime.utcnow()
                db.commit()
                return {"message": "Task failed", "task_id": task.id, "error": error_msg}
            
            # Update step status
            step["completed"] = True
            step["result"] = step_result
            
            # Add to results
            results[f"step_{step_number}"] = step_result
            
            # Update progress
            completed_steps += 1
            task.progress = int((completed_steps / total_steps) * 100)
            task.updated_at = datetime.utcnow()
            
            try:
        db.commit()
                logger.info(f"[Task {task_id}] Progress updated: {task.progress}%")
            except Exception as db_error:
                logger.error(f"[Task {task_id}] Failed to update task progress: {str(db_error)}")
            
            # Send progress notification
            try:
        from notification import notify_task_update
                await notify_task_update(task)
                logger.info(f"[Task {task_id}] Sent progress notification")
            except Exception as e:
                logger.warning(f"[Task {task_id}] Failed to send progress notification: {str(e)}")
            
        # Mark task as completed
        task.status = TaskStatus.COMPLETED
        task.completed_at = datetime.utcnow()
        task.result = results
        
        try:
        db.commit()
            logger.info(f"[Task {task_id}] Task marked as completed")
        except Exception as db_error:
            logger.error(f"[Task {task_id}] Failed to update task status to completed: {str(db_error)}")
        
        # Send completion notification
        try:
        from notification import notify_task_completion
            await notify_task_completion(task)
            logger.info(f"[Task {task_id}] Sent completion notification")
        except Exception as e:
            logger.warning(f"[Task {task_id}] Failed to send completion notification: {str(e)}")
        
        return {
            "message": "Task completed successfully",
            "task_id": task.id,
            "results": results
        }
        
    except Exception as e:
        # Mark task as failed
        logger.error(f"[Task {task_id}] Task execution failed: {str(e)}")
        task.status = TaskStatus.FAILED
        task.error = str(e)
        task.updated_at = datetime.utcnow()
        
        try:
        db.commit()
            logger.info(f"[Task {task_id}] Task marked as failed")
        except Exception as db_error:
            logger.error(f"[Task {task_id}] Failed to update task status to failed: {str(db_error)}")
        
        # Send failure notification
        try:
        from notification import notify_task_update
            await notify_task_update(task)
            logger.info(f"[Task {task_id}] Sent failure notification")
        except Exception as notif_error:
            logger.warning(f"[Task {task_id}] Failed to send failure notification: {str(notif_error)}")
        
        return {
            "message": "Task failed",
            "task_id": task.id,
            "error": str(e)
        }

def validate_step(step: Dict[str, Any], logger, task_id: str, step_number: int) -> bool:
    """Validate that a step has all required fields and parameters"""
    action = step.get("action")
    params = step.get("params", {})
    
    if not action:
        logger.error(f"[Task {task_id}] Step {step_number} missing action")
        return False
        
    # Normalize action to uppercase for consistency
    action = action.upper() if action else None
        
    # Check that action is a valid TaskAction
    valid_actions = [e.value for e in TaskAction]
    if action not in valid_actions:
        logger.error(f"[Task {task_id}] Step {step_number} has invalid action: {action}")
        logger.error(f"[Task {task_id}] Valid actions are: {valid_actions}")
        return False
    
    # Validate required parameters for each action type
    if action in ["DELETE", "ARCHIVE", "MARK_READ", "MARK_UNREAD", "STAR", "UNSTAR"]:
        if not params.get("message_ids"):
            logger.error(f"[Task {task_id}] Step {step_number} ({action}) missing required parameter: message_ids")
            return False
    
    if action == "LABEL":
        if not params.get("message_ids"):
            logger.error(f"[Task {task_id}] Step {step_number} (LABEL) missing required parameter: message_ids")
            return False
        if "label_name" not in params:
            logger.error(f"[Task {task_id}] Step {step_number} (LABEL) missing required parameter: label_name")
            return False
    
    if action == "SEARCH":
        if "query" not in params:
            logger.error(f"[Task {task_id}] Step {step_number} (SEARCH) missing required parameter: query")
            return False
    
    return True

def execute_step(step: Dict[str, Any], gmail_service: GmailService, db: Session, user: User) -> Dict[str, Any]:
    """Execute a single task step"""
    action = step.get("action")
    # Normalize action to uppercase
    if action and isinstance(action, str):
        action = action.upper()
    # Normalize action to uppercase
    if action and isinstance(action, str):
        action = action.upper()
    params = step.get("params", {})
    
    # Normalize action to uppercase for consistency
    if action:
        action = action.upper()
    
    if action == "DELETE":
        # Delete emails
        message_ids = params.get("message_ids", [])
        permanent = params.get("permanent", False)
        
        if permanent:
            success = gmail_service.batch_delete_messages(message_ids)
        else:
            success = gmail_service.batch_modify_messages(message_ids, add_label_ids=["TRASH"], remove_label_ids=["INBOX"])
            
        # Update local database
        for message_id in message_ids:
            email = db.query(Email).filter(
                Email.gmail_id == message_id,
                Email.user_id == user.id
            ).first()
            
            if email:
                if permanent:
                    db.delete(email)
                else:
                    email.is_deleted = True
                    if "TRASH" not in email.labels:
                        email.labels = list(set(email.labels + ["TRASH"]))
                    if "INBOX" in email.labels:
                        email.labels.remove("INBOX")
        
        db.commit()
        return {"success": success, "count": len(message_ids)}
        
    elif action == "ARCHIVE":
        # Archive emails
        message_ids = params.get("message_ids", [])
        success = gmail_service.batch_modify_messages(message_ids, remove_label_ids=["INBOX"])
        
        # Update local database
        for message_id in message_ids:
            email = db.query(Email).filter(
                Email.gmail_id == message_id,
                Email.user_id == user.id
            ).first()
            
            if email:
                email.is_archived = True
                if "INBOX" in email.labels:
                    email.labels.remove("INBOX")
        
        db.commit()
        return {"success": success, "count": len(message_ids)}
        
    elif action == "LABEL":
        # Apply labels to emails
        message_ids = params.get("message_ids", [])
        label_name = params.get("label_name")
        remove = params.get("remove", False)
        
        # Ensure label exists
        label_id = gmail_service.ensure_label(label_name)
        
        if remove:
            success = gmail_service.batch_modify_messages(message_ids, remove_label_ids=[label_id])
        else:
            success = gmail_service.batch_modify_messages(message_ids, add_label_ids=[label_id])
            
        # Update local database
        for message_id in message_ids:
            email = db.query(Email).filter(
                Email.gmail_id == message_id,
                Email.user_id == user.id
            ).first()
            
            if email:
                if remove and label_id in email.labels:
                    email.labels.remove(label_id)
                elif not remove and label_id not in email.labels:
                    email.labels.append(label_id)
        
        db.commit()
        return {"success": success, "count": len(message_ids), "label": label_name}
        
    elif action == "SEARCH":
        # Search for emails
        query = params.get("query", "")
        max_results = params.get("max_results", 100)
        
        messages = gmail_service.search_messages(query, max_results=max_results)
        message_ids = [msg["id"] for msg in messages]
        
        return {"success": True, "count": len(message_ids), "message_ids": message_ids}
        
    elif action == "MARK_READ":
        # Mark emails as read
        message_ids = params.get("message_ids", [])
        success = gmail_service.batch_modify_messages(message_ids, remove_label_ids=["UNREAD"])
        return {"success": success, "count": len(message_ids)}
        
    elif action == "MARK_UNREAD":
        # Mark emails as unread
        message_ids = params.get("message_ids", [])
        success = gmail_service.batch_modify_messages(message_ids, add_label_ids=["UNREAD"])
        return {"success": success, "count": len(message_ids)}
        
    elif action == "STAR":
        # Star emails
        message_ids = params.get("message_ids", [])
        success = gmail_service.batch_modify_messages(message_ids, add_label_ids=["STARRED"])
        return {"success": success, "count": len(message_ids)}
        
    elif action == "UNSTAR":
        # Unstar emails
        message_ids = params.get("message_ids", [])
        success = gmail_service.batch_modify_messages(message_ids, remove_label_ids=["STARRED"])
        return {"success": success, "count": len(message_ids)}
        
    else:
        raise ValueError(f"Unsupported action: {action}")

def process_ai_task(task_description: str, user: User, db: Session) -> Dict[str, Any]:
    """Process a task described in natural language using AI
    
    This function uses OpenAI to parse natural language requests into actionable
    email management tasks, then creates and executes those tasks using the Gmail API.
    """
    import json
    from openai import OpenAI
    
    # Get email statistics for context
    total_emails = db.query(Email).filter(Email.user_id == user.id).count()
    spam_count = db.query(Email).filter(Email.user_id == user.id, Email.is_spam == True).count()
    unread_count = db.query(Email).filter(
        Email.user_id == user.id,
        Email.labels.contains(["UNREAD"])
    ).count()
    inbox_count = db.query(Email).filter(
        Email.user_id == user.id,
        Email.labels.contains(["INBOX"])
    ).count()
    
    # Try AI-based task parsing first
    try:
        client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        
        # Construct the system prompt with available actions and task examples
        system_prompt = f"""
        You are an expert AI assistant that creates executable email management tasks based on user requests.
        
        USER EMAIL STATISTICS:
        - Total emails: {total_emails}
        - Spam emails: {spam_count}
        - Unread emails: {unread_count}
        - Inbox emails: {inbox_count}
        
        AVAILABLE ACTIONS:
        - DELETE: Delete emails (moves to trash by default)
        - ARCHIVE: Archive emails (removes from inbox)
        - LABEL: Apply or remove Gmail labels
        - MARK_READ: Mark emails as read
        - MARK_UNREAD: Mark emails as unread
        - STAR: Star emails
        - UNSTAR: Remove star from emails
        - SEARCH: Search for emails with specific criteria
        
        VALID TASK TYPES:
        - EMAIL_CLEANUP: For tasks that delete or clean up emails
        - EMAIL_ORGANIZATION: For tasks that organize or categorize emails
        - EMAIL_SEARCH: For search-related tasks
        - CUSTOM: For multi-step or complex tasks
        
        Your task is to:
        1. Parse the user's request precisely
        2. Determine exactly which action(s) they want to perform
        3. Identify exactly which emails should be affected using search criteria
        4. Create a detailed task plan with specific steps
        
        PROVIDE YOUR RESPONSE AS JSON with this EXACT structure:
        {{
          "task_type": "EMAIL_CLEANUP|EMAIL_ORGANIZATION|EMAIL_SEARCH|CUSTOM",
          "description": "A clear description of the task",
          "steps": [
            {{
              "action": "One of the AVAILABLE ACTIONS listed above",
              "params": {{
                "query": "Search query to find relevant emails (REQUIRED if message_ids is empty)",
                "message_ids": [], 
                "permanent": false, 
                "label_name": "Name of label (REQUIRED for LABEL action)",
                "remove": false 
              }}
            }}
          ]
        }}
        
        EXAMPLE 1 - Single action task:
        User: "Delete all my spam emails"
        Response:
        {{
          "task_type": "EMAIL_CLEANUP",
          "description": "Delete all spam emails",
          "steps": [
            {{
              "action": "DELETE",
              "params": {{
                "query": "is:spam",
                "message_ids": [],
                "permanent": false
              }}
            }}
          ]
        }}
        
        EXAMPLE 2 - Archive task:
        User: "Archive all emails from Amazon older than 3 months"
        Response:
        {{
          "task_type": "EMAIL_ORGANIZATION",
          "description": "Archive old Amazon emails",
          "steps": [
            {{
              "action": "ARCHIVE",
              "params": {{
                "query": "from:amazon older_than:3m",
                "message_ids": []
              }}
            }}
          ]
        }}
        
        EXAMPLE 3 - Label task:
        User: "Label all emails from my boss as important"
        Response:
        {{
          "task_type": "EMAIL_ORGANIZATION",
          "description": "Label boss emails as important",
          "steps": [
            {{
              "action": "LABEL",
              "params": {{
                "query": "from:boss@company.com",
                "message_ids": [],
                "label_name": "Important",
                "remove": false
              }}
            }}
          ]
        }}
        
        EXAMPLE 4 - Mark as read task:
        User: "Mark all newsletter emails as read"
        Response:
        {{
          "task_type": "EMAIL_ORGANIZATION",
          "description": "Mark newsletter emails as read",
          "steps": [
            {{
              "action": "MARK_READ",
              "params": {{
                "query": "category:promotions",
                "message_ids": []
              }}
            }}
          ]
        }}
        
        EXAMPLE 5 - Multi-step task:
        User: "Find all unread newsletters, mark them as read, then archive them"
        Response:
        {{
          "task_type": "CUSTOM",
          "description": "Process unread newsletters",
          "steps": [
            {{
              "action": "MARK_READ",
              "params": {{
                "query": "is:unread category:promotions",
                "message_ids": []
              }}
            }},
            {{
              "action": "ARCHIVE",
              "params": {{
                "query": "is:read category:promotions",
                "message_ids": []
              }}
            }}
          ]
        }}
        
        SEARCH QUERY SYNTAX:
        - "from:email@example.com" - Emails from specific sender
        - "to:email@example.com" - Emails to specific recipient
        - "subject:keyword" - Emails with keyword in subject
        - "is:unread" - Unread emails
        - "is:read" - Read emails
        - "is:starred" - Starred emails 
        - "is:important" - Important emails
        - "category:primary|social|promotions|updates|forums" - By Gmail category
        - "older_than:1d|1w|1m|1y" - By age (days, weeks, months, years)
        - "newer_than:1d|1w|1m|1y" - By recency
        - "has:attachment" - Emails with attachments
        
        IMPORTANT RULES:
        - ALWAYS include a "query" parameter if "message_ids" is empty
        - NEVER leave both "query" and "message_ids" empty
        - ALWAYS include "label_name" for LABEL actions
        - ENSURE the task has at least one step
        - USE precise search queries that match exactly what the user wants
        - DO NOT include unnecessary parameters
        
        If you can't determine a valid task, respond with: {{"error": "specific reason why you can't create this task"}}
        """
        
        # User message describing the email task
        user_message = f"Task: {task_description}"
        
        # Setup logging for task creation
        import logging
        logger = logging.getLogger("task_creation")
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
        
        logger.info(f"Processing task request: '{task_description}'")
        
        # Try up to 2 times with different approaches if needed
        for attempt in range(2):
            try:
        # Adjust temperature based on attempt (more precise on second try)
                temperature = 0.1 if attempt > 0 else 0.2
                
                # Add attempt-specific guidance
                attempt_guidance = ""
                if attempt > 0:
                    logger.info("First attempt failed, trying with more specific guidance")
                    attempt_guidance = f"""
                    IMPORTANT: The previous response didn't create a valid task structure.
                    Focus on these common issues:
                    1. Make sure you specify a valid action from the AVAILABLE ACTIONS list
                    2. Include a proper search query in the "query" parameter
                    3. For LABEL actions, ensure you include a "label_name"
                    4. Make sure the user's request is translated into Gmail search syntax correctly
                    
                    The user's request is: "{task_description}"
                    
                    Create a simple, direct task with clear steps.
                    """
                
                # Call the OpenAI API with attempt-specific settings
                logger.info(f"Calling OpenAI API (attempt {attempt+1})")
                response = client.chat.completions.create(
                    model=os.getenv("OPENAI_MODEL", "gpt-4o-mini"),
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_message + attempt_guidance}
                    ],
                    temperature=temperature,  
                    response_format={"type": "json_object"}  # Enforce JSON format
                )
                
                # Parse the response
                response_content = response.choices[0].message.content
                logger.info(f"Got response: {response_content[:100]}...")
                
                try:
        task_data = json.loads(response_content)
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse JSON: {str(e)}")
                    if attempt == 1:  # Last attempt failed
                        return {"message": "I couldn't understand how to complete this task. Please try rephrasing your request.", "task_created": False}
                    continue  # Try again
                
                # Check for error response
                if "error" in task_data:
                    if attempt == 1:  # Last attempt failed
                        return {"message": f"I couldn't create a task: {task_data['error']}", "task_created": False}
                    continue  # Try again
                
                # Validate task structure
                if "steps" not in task_data or not task_data["steps"] or not isinstance(task_data["steps"], list):
                    logger.error("Invalid task structure: missing or empty steps")
                    if attempt == 1:  # Last attempt failed
                        return {"message": "I couldn't create a proper task structure. Please try rephrasing your request.", "task_created": False}
                    continue  # Try again
                
                # Process each step to translate search queries into message IDs
                processed_steps = []
                gmail_service = None
                
                for step_index, step in enumerate(task_data.get("steps", [])):
                    step_num = step_index + 1
                    action = step.get("action")
                    params = step.get("params", {})
                    
                    # Validate action - normalize to uppercase to handle both cases
                    if not action:
                        logger.error(f"Step {step_num}: Missing action")
                        if attempt == 1:  # Last attempt failed
                            return {"message": f"Missing action in step {step_num}", "task_created": False}
                        break  # Try again
                    
                    # Normalize action to uppercase
                    action = action.upper()
                    if action not in [e.value for e in TaskAction]:
                        logger.error(f"Step {step_num}: Invalid action: {action}")
                        if attempt == 1:  # Last attempt failed
                            return {"message": f"Invalid action in step {step_num}: {action}", "task_created": False}
                        break  # Try again
                    
                    # Check for required parameters based on action
                    if action == "LABEL" and "label_name" not in params:
                        logger.error(f"Step {step_num}: Missing label_name parameter for LABEL action")
                        if attempt == 1:  # Last attempt failed
                            return {"message": "Label actions require a label name", "task_created": False}
                        break  # Try again
                    
                    # Process query to get message IDs if needed
                    if "message_ids" not in params or not params["message_ids"]:
                        if "query" not in params or not params["query"]:
                            logger.error(f"Step {step_num}: Missing both query and message_ids")
                            if attempt == 1:  # Last attempt failed
                                return {"message": "Steps must include either a search query or message IDs", "task_created": False}
                            break  # Try again
                        
                        # Create Gmail service instance (reuse if already created)
                        if not gmail_service:
                            gmail_service = GmailService(user)
                        
                        query = params["query"]
                        logger.info(f"Step {step_num}: Searching for emails with query: '{query}'")
                        
                        # Search for matching messages
                        try:
        messages = gmail_service.search_messages(query, max_results=500)
                            message_ids = [msg["id"] for msg in messages]
                            
                            if not message_ids:
                                logger.warning(f"Step {step_num}: No emails found matching query: '{query}'")
                                return {"message": f"No emails found matching the search criteria: '{query}'", "task_created": False}
                            
                            logger.info(f"Step {step_num}: Found {len(message_ids)} matching emails")
                            
                            # Update params with found message IDs
                            params["message_ids"] = message_ids
                            # Keep the query for reference
                        except Exception as search_error:
                            logger.error(f"Step {step_num}: Error searching emails: {str(search_error)}")
                            if attempt == 1:  # Last attempt failed
                                return {"message": f"Error searching for emails: {str(search_error)}", "task_created": False}
                            break  # Try again
                    
                    # Create the processed step
                    processed_steps.append(
                        TaskStep(
                            action=action,
                            params=params
                        )
                    )
                
                # Check if we have valid steps
                if not processed_steps:
                    if attempt == 1:  # Last attempt failed
                        return {"message": "I couldn't create valid task steps. Please try rephrasing your request.", "task_created": False}
                    continue  # Try again
                
                # Create the task request
                task_type = task_data.get("task_type")
                if task_type not in [e.value for e in TaskType]:
                    task_type = TaskType.CUSTOM
                
                task_request = TaskRequest(
                    task_type=task_type,
                    description=task_data.get("description", task_description),
                    steps=processed_steps
                )
                
                # Create and save the task
                task = create_task(db, str(user.id), task_request)
                
                logger.info(f"Successfully created task {task.id} with {len(processed_steps)} steps")
                
                return {
                    "message": f"Created task: {task_data.get('description')}",
                    "task_id": task.id,
                    "task_created": True
                }
                
            except Exception as e:
                logger.error(f"Error during task creation (attempt {attempt+1}): {str(e)}")
                if attempt == 1:  # Last attempt failed
                    return {"message": f"Failed to create task: {str(e)}", "task_created": False}
                # Otherwise try again
        
        # Should not reach here, but just in case
        return {"message": "Unexpected error creating task", "task_created": False}
    
    except Exception as e:
        print(f"Error using AI for task parsing: {str(e)}")
        
        # Fall back to rule-based parsing for common cases
    task_description_lower = task_description.lower()
    
    # Task type detection
    task_type = TaskType.CUSTOM
    if any(term in task_description_lower for term in ["delete", "remove", "clean", "trash"]):
        task_type = TaskType.EMAIL_CLEANUP
        elif any(term in task_description_lower for term in ["organize", "label", "categorize", "move", "archive"]):
        task_type = TaskType.EMAIL_ORGANIZATION
    elif any(term in task_description_lower for term in ["find", "search", "look for"]):
        task_type = TaskType.EMAIL_SEARCH
    
    # Simple task parsing examples
    if "delete all spam" in task_description_lower:
        # Find spam emails first
        spam_emails = db.query(Email).filter(
            Email.user_id == user.id,
            Email.is_spam == True
        ).all()
        
        message_ids = [email.gmail_id for email in spam_emails if email.gmail_id]
        
        if not message_ids:
            return {"message": "No spam emails found", "task_created": False}
        
        # Create task
        task_request = TaskRequest(
            task_type=TaskType.EMAIL_CLEANUP,
            description=f"Delete {len(message_ids)} spam emails",
            steps=[
                TaskStep(
                    action=TaskAction.DELETE,
                    params={"message_ids": message_ids, "permanent": False}
                )
            ]
        )
        
        task = create_task(db, str(user.id), task_request)
        return {
            "message": f"Created task to delete {len(message_ids)} spam emails",
            "task_id": task.id,
            "task_created": True
        }
        
        elif "archive unread" in task_description_lower or "archive all unread" in task_description_lower:
        # Find unread emails
        unread_emails = db.query(Email).filter(
            Email.user_id == user.id,
            Email.labels.contains(["UNREAD"])
        ).all()
        
        message_ids = [email.gmail_id for email in unread_emails if email.gmail_id]
        
        if not message_ids:
            return {"message": "No unread emails found", "task_created": False}
        
        # Create task
        task_request = TaskRequest(
            task_type=TaskType.EMAIL_ORGANIZATION,
            description=f"Archive {len(message_ids)} unread emails",
            steps=[
                TaskStep(
                    action=TaskAction.ARCHIVE,
                    params={"message_ids": message_ids}
                )
            ]
        )
        
        task = create_task(db, str(user.id), task_request)
        return {
            "message": f"Created task to archive {len(message_ids)} unread emails",
            "task_id": task.id,
            "task_created": True
        }
        
    # Default response for unsupported tasks
    return {
            "message": "I don't know how to perform this task yet. Please try a simpler request or different wording.",
        "task_created": False
    }

# Routes
@router.post("/tasks", response_model=TaskResponse)
async def create_task_endpoint(
    task_request: TaskRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new task"""
    task = create_task(db, str(current_user.id), task_request)
    
    return TaskResponse(
        task_id=task.id,
        status=task.status,
        description=task.description,
        created_at=task.created_at,
        updated_at=task.updated_at,
        progress=task.progress
    )

@router.post("/tasks/{task_id}/execute", response_model=TaskResponse)
async def execute_task_endpoint(
    task_id: str,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Execute a task"""
    task = db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == current_user.id
    ).first()
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    # Execute task in background
    background_tasks.add_task(execute_task, db, task, current_user)
    
    # Update task status
    task.status = TaskStatus.IN_PROGRESS
    task.updated_at = datetime.utcnow()
    db.commit()
    
    return TaskResponse(
        task_id=task.id,
        status=TaskStatus.IN_PROGRESS,
        description=task.description,
        created_at=task.created_at,
        updated_at=datetime.utcnow(),
        progress=0
    )

@router.post("/tasks/{task_id}/retry", response_model=TaskResponse)
async def retry_task_endpoint(
    task_id: str,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Retry a failed task or restart a completed task"""
    import logging
    logger = logging.getLogger("task_retry")
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
    
    task = db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == current_user.id
    ).first()
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    # Only allow retry for failed tasks or restart for completed tasks
    if task.status not in [TaskStatus.FAILED, TaskStatus.COMPLETED, TaskStatus.CANCELLED]:
        raise HTTPException(status_code=400, 
                           detail=f"Task cannot be retried with status '{task.status}'. Only failed, completed, or cancelled tasks can be retried.")
    
    logger.info(f"Retrying task {task_id} (previous status: {task.status})")
    
    # Reset the task steps' completion status
    if task.steps:
        for step in task.steps:
            if "completed" in step:
                step["completed"] = False
            if "result" in step:
                step["result"] = None
            if "error" in step:
                step["error"] = None
    
    # Reset task status
    task.status = TaskStatus.PENDING
    task.error = None
    task.progress = 0
    task.result = None
    task.updated_at = datetime.utcnow()
    task.completed_at = None
    db.commit()
    
    # If this is a simple task, execute it immediately, otherwise in background
    if is_simple_task(task):
        logger.info(f"Executing simple retry task {task_id} directly")
        try:
        result = await execute_task(db, task, current_user)
            # Add result to response for immediate feedback
            return TaskResponse(
                task_id=task.id,
                status=task.status,
                description=task.description,
                created_at=task.created_at,
                updated_at=task.updated_at,
                completed_at=task.completed_at,
                progress=task.progress,
                result=task.result,
                error=task.error
            )
        except Exception as e:
            logger.error(f"Error during immediate retry: {str(e)}")
            # Fall through to background execution as fallback
    
    # Execute in background for more complex tasks or as fallback
    background_tasks.add_task(execute_task, db, task, current_user)
    
    # Update status
    task.status = TaskStatus.IN_PROGRESS
    task.updated_at = datetime.utcnow()
    db.commit()
    
    return TaskResponse(
        task_id=task.id,
        status=TaskStatus.IN_PROGRESS,
        description=task.description,
        created_at=task.created_at,
        updated_at=datetime.utcnow(),
        progress=0
    )

@router.post("/tasks/{task_id}/details")
async def get_task_details(
    task_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get detailed explanation of a task's steps"""
    task = db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == current_user.id
    ).first()
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    steps = task.steps or []
    detailed_steps = []
    
    for i, step in enumerate(steps):
        action = step.get("action")
        params = step.get("params", {})
        message_ids = params.get("message_ids", [])
        completed = step.get("completed", False)
        
        # Create human-readable description
        if action == "DELETE":
            permanent = params.get("permanent", False)
            action_desc = f"Permanently delete" if permanent else f"Move to trash"
            email_count = len(message_ids)
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"{action_desc} {email_count} emails",
                "completed": completed
            })
        
        elif action == "ARCHIVE":
            email_count = len(message_ids)
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"Archive {email_count} emails (remove from inbox)",
                "completed": completed
            })
            
        elif action == "LABEL":
            label_name = params.get("label_name", "")
            remove = params.get("remove", False)
            email_count = len(message_ids)
            action_desc = f"Remove label '{label_name}' from" if remove else f"Apply label '{label_name}' to"
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"{action_desc} {email_count} emails",
                "completed": completed
            })
            
        elif action == "MARK_READ":
            email_count = len(message_ids)
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"Mark {email_count} emails as read",
                "completed": completed
            })
            
        elif action == "MARK_UNREAD":
            email_count = len(message_ids)
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"Mark {email_count} emails as unread",
                "completed": completed
            })
            
        elif action == "STAR":
            email_count = len(message_ids)
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"Star {email_count} emails",
                "completed": completed
            })
            
        elif action == "UNSTAR":
            email_count = len(message_ids)
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"Remove star from {email_count} emails",
                "completed": completed
            })
            
        elif action == "SEARCH":
            query = params.get("query", "")
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"Search for emails with query: '{query}'",
                "completed": completed
            })
        
        else:
            detailed_steps.append({
                "step_number": i + 1,
                "description": f"Perform {action} operation",
                "completed": completed
            })
    
    return {
        "task_id": task.id,
        "description": task.description,
        "status": task.status,
        "progress": task.progress,
        "created_at": task.created_at,
        "detailed_steps": detailed_steps,
        "total_steps": len(steps)
    }

@router.get("/tasks/{task_id}", response_model=TaskResponse)
async def get_task_status(
    task_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get task status"""
    task = db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == current_user.id
    ).first()
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    return TaskResponse(
        task_id=task.id,
        status=task.status,
        description=task.description,
        created_at=task.created_at,
        updated_at=task.updated_at,
        completed_at=task.completed_at,
        progress=task.progress,
        result=task.result,
        error=task.error
    )

@router.get("/tasks", response_model=List[TaskResponse])
async def list_tasks(
    status: Optional[TaskStatus] = None,
    limit: int = 10,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List tasks"""
    query = db.query(Task).filter(Task.user_id == current_user.id)
    
    if status:
        query = query.filter(Task.status == status)
    
    tasks = query.order_by(Task.created_at.desc()).limit(limit).all()
    
    return [
        TaskResponse(
            task_id=task.id,
            status=task.status,
            description=task.description,
            created_at=task.created_at,
            updated_at=task.updated_at,
            completed_at=task.completed_at,
            progress=task.progress,
            result=task.result,
            error=task.error
        )
        for task in tasks
    ]

@router.post("/ai-task")
async def create_ai_task(
    task_description: str,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create and execute a task from natural language description"""
    result = process_ai_task(task_description, current_user, db)
    
    if result.get("task_created"):
        task_id = result.get("task_id")
        task = db.query(Task).filter(
            Task.id == task_id,
            Task.user_id == current_user.id
        ).first()
        
        if task:
            # Update task status
            task.status = TaskStatus.IN_PROGRESS
            task.updated_at = datetime.utcnow()
            db.commit()
            
            # Execute task in background
            background_tasks.add_task(execute_task, db, task, current_user)
            
            return {
                "message": result.get("message"),
                "task_id": task_id,
                "status": "started",
                "description": task.description
            }
    
    return {
        "message": result.get("message", "Failed to create task"),
        "status": "failed_to_create"
    }

@router.delete("/tasks/{task_id}")
async def cancel_task(
    task_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Cancel a task"""
    task = db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == current_user.id
    ).first()
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    if task.status in [TaskStatus.COMPLETED, TaskStatus.FAILED]:
        raise HTTPException(status_code=400, detail="Cannot cancel completed or failed task")
    
    task.status = TaskStatus.CANCELLED
    task.updated_at = datetime.utcnow()
    db.commit()
    
    return {"message": "Task cancelled", "task_id": task_id}

# Helper function to determine if a task is simple enough for immediate execution
def is_simple_task(task: Task) -> bool:
    """
    Determine if a task is simple enough to be executed immediately instead of in the background.
    Simple tasks are those with a single step and fewer than 50 emails to process.
    """
    if not task or not task.steps:
        return False
        
    # Complex if more than one step
    if len(task.steps) > 1:
        return False
    
    # Get the step
    step = task.steps[0]
    
    # Get message IDs
    message_ids = step.get("params", {}).get("message_ids", [])
    
    # Simple if fewer than 50 emails to process
    return len(message_ids) < 50

# Export router
task_executor_router = router
